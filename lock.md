# Lock

一个东西, 能用两个锁保护吗?

``` c
struct {
    int a;
    int b;
    lock la;
    lock lb;
}
```

定义, 能与不能. 什么叫做一个锁能够保护一个数据 ?
更正为: 怎样使用一个锁, 能够保护一个数据. 我们需要一个使用锁与数据的约定,
并遵循这个 **约定**, 才能保护一个数据.

定义: 保护一个数据, 指禁止多个线程同时访问这个数据. 说这个数据是安全的.

定义: 访问一个数据, 读,或者写这个数据.

定义, 数据. data.

定义锁, lock, 两个状态,  { 1, 0 }, 1 : hold, 锁住, 0 : free, 没有被锁.
- 两个操作 l.lock(), l.unlock().
- l = 0 时, l.lock() 后, l = 1; l.unlock(), 报错(或者无事发生)
- l = 1 是, l.lock() 后 进程阻塞; l.unlock() 后, l = 0.

定义, 线程. T, 

定义, 多线程{T_1, T_2, T_3}

例: 
```
int a;
lock l;
```
约定, 在使用前 l.lock(), 使用后 l.unlock().

证明, 此约定是正确的. 即证明不可能有两个线程同时使用 a.
即证明, 有一个线程在使用时, 其他线程无法使用.. 显然.


问题: 

一个东西, 能用两个锁保护吗?

``` c
struct {
    int a;
    int b;
    lock la;
    lock lb;
}
```

这个问题描述就有问题了. 能用一个锁保护, 当然能够用两个锁保护, 一个锁不使用就行了.

换个问题: 这个约定能够保护数据吗? 约定如下:

- 使用 a 之前, la.lock(), 结束后 la.unlock()
- 使用 b 之前, lb.lock(), 结束后 lb.unlock()

根据之前的结论, a 是安全的, b 是安全的. 所以 struct {a, b} 是安全的吗?

定义: 一个由多个部分组成的 data 安全, 指 每个部分都是安全的.


